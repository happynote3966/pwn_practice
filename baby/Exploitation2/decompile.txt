
exploit2:     file format elf32-i386


Disassembly of section .init:

0804856c <_init>:
 804856c:	push   ebx
 804856d:	sub    esp,0x8
 8048570:	call   8048575 <_init+0x9>
 8048575:	pop    ebx
 8048576:	add    ebx,0x1a7f
 804857c:	mov    eax,DWORD PTR [ebx-0x4]
 8048582:	test   eax,eax
 8048584:	je     804858b <_init+0x1f>
 8048586:	call   8048630 <__gmon_start__@plt>
 804858b:	call   80487c0 <frame_dummy>
 8048590:	call   8048ca0 <__do_global_ctors_aux>
 8048595:	add    esp,0x8
 8048598:	pop    ebx
 8048599:	ret    

Disassembly of section .plt:

080485a0 <setsockopt@plt-0x10>:
 80485a0:	push   DWORD PTR ds:0x8049ff8
 80485a6:	jmp    DWORD PTR ds:0x8049ffc
 80485ac:	add    BYTE PTR [eax],al
	...

080485b0 <setsockopt@plt>:
 80485b0:	jmp    DWORD PTR ds:0x804a000
 80485b6:	push   0x0
 80485bb:	jmp    80485a0 <_init+0x34>

080485c0 <printf@plt>:
 80485c0:	jmp    DWORD PTR ds:0x804a004
 80485c6:	push   0x8
 80485cb:	jmp    80485a0 <_init+0x34>

080485d0 <time@plt>:
 80485d0:	jmp    DWORD PTR ds:0x804a008
 80485d6:	push   0x10
 80485db:	jmp    80485a0 <_init+0x34>

080485e0 <inet_ntoa@plt>:
 80485e0:	jmp    DWORD PTR ds:0x804a00c
 80485e6:	push   0x18
 80485eb:	jmp    80485a0 <_init+0x34>

080485f0 <htons@plt>:
 80485f0:	jmp    DWORD PTR ds:0x804a010
 80485f6:	push   0x20
 80485fb:	jmp    80485a0 <_init+0x34>

08048600 <perror@plt>:
 8048600:	jmp    DWORD PTR ds:0x804a014
 8048606:	push   0x28
 804860b:	jmp    80485a0 <_init+0x34>

08048610 <accept@plt>:
 8048610:	jmp    DWORD PTR ds:0x804a018
 8048616:	push   0x30
 804861b:	jmp    80485a0 <_init+0x34>

08048620 <waitpid@plt>:
 8048620:	jmp    DWORD PTR ds:0x804a01c
 8048626:	push   0x38
 804862b:	jmp    80485a0 <_init+0x34>

08048630 <__gmon_start__@plt>:
 8048630:	jmp    DWORD PTR ds:0x804a020
 8048636:	push   0x40
 804863b:	jmp    80485a0 <_init+0x34>

08048640 <exit@plt>:
 8048640:	jmp    DWORD PTR ds:0x804a024
 8048646:	push   0x48
 804864b:	jmp    80485a0 <_init+0x34>

08048650 <srand@plt>:
 8048650:	jmp    DWORD PTR ds:0x804a028
 8048656:	push   0x50
 804865b:	jmp    80485a0 <_init+0x34>

08048660 <__libc_start_main@plt>:
 8048660:	jmp    DWORD PTR ds:0x804a02c
 8048666:	push   0x58
 804866b:	jmp    80485a0 <_init+0x34>

08048670 <bind@plt>:
 8048670:	jmp    DWORD PTR ds:0x804a030
 8048676:	push   0x60
 804867b:	jmp    80485a0 <_init+0x34>

08048680 <rand@plt>:
 8048680:	jmp    DWORD PTR ds:0x804a034
 8048686:	push   0x68
 804868b:	jmp    80485a0 <_init+0x34>

08048690 <fork@plt>:
 8048690:	jmp    DWORD PTR ds:0x804a038
 8048696:	push   0x70
 804869b:	jmp    80485a0 <_init+0x34>

080486a0 <sigemptyset@plt>:
 80486a0:	jmp    DWORD PTR ds:0x804a03c
 80486a6:	push   0x78
 80486ab:	jmp    80485a0 <_init+0x34>

080486b0 <freeaddrinfo@plt>:
 80486b0:	jmp    DWORD PTR ds:0x804a040
 80486b6:	push   0x80
 80486bb:	jmp    80485a0 <_init+0x34>

080486c0 <listen@plt>:
 80486c0:	jmp    DWORD PTR ds:0x804a044
 80486c6:	push   0x88
 80486cb:	jmp    80485a0 <_init+0x34>

080486d0 <socket@plt>:
 80486d0:	jmp    DWORD PTR ds:0x804a048
 80486d6:	push   0x90
 80486db:	jmp    80485a0 <_init+0x34>

080486e0 <getaddrinfo@plt>:
 80486e0:	jmp    DWORD PTR ds:0x804a04c
 80486e6:	push   0x98
 80486eb:	jmp    80485a0 <_init+0x34>

080486f0 <sigaction@plt>:
 80486f0:	jmp    DWORD PTR ds:0x804a050
 80486f6:	push   0xa0
 80486fb:	jmp    80485a0 <_init+0x34>

08048700 <recv@plt>:
 8048700:	jmp    DWORD PTR ds:0x804a054
 8048706:	push   0xa8
 804870b:	jmp    80485a0 <_init+0x34>

08048710 <close@plt>:
 8048710:	jmp    DWORD PTR ds:0x804a058
 8048716:	push   0xb0
 804871b:	jmp    80485a0 <_init+0x34>

08048720 <send@plt>:
 8048720:	jmp    DWORD PTR ds:0x804a05c
 8048726:	push   0xb8
 804872b:	jmp    80485a0 <_init+0x34>

Disassembly of section .text:

08048730 <_start>:
 8048730:	xor    ebp,ebp
 8048732:	pop    esi
 8048733:	mov    ecx,esp
 8048735:	and    esp,0xfffffff0
 8048738:	push   eax
 8048739:	push   esp
 804873a:	push   edx
 804873b:	push   0x8048c90
 8048740:	push   0x8048c20
 8048745:	push   ecx
 8048746:	push   esi
 8048747:	push   0x804892b
 804874c:	call   8048660 <__libc_start_main@plt>
 8048751:	hlt    
 8048752:	nop
 8048753:	nop
 8048754:	nop
 8048755:	nop
 8048756:	nop
 8048757:	nop
 8048758:	nop
 8048759:	nop
 804875a:	nop
 804875b:	nop
 804875c:	nop
 804875d:	nop
 804875e:	nop
 804875f:	nop

08048760 <__do_global_dtors_aux>:
 8048760:	push   ebp
 8048761:	mov    ebp,esp
 8048763:	push   ebx
 8048764:	sub    esp,0x4
 8048767:	cmp    BYTE PTR ds:0x804a068,0x0
 804876e:	jne    80487af <__do_global_dtors_aux+0x4f>
 8048770:	mov    eax,ds:0x804a06c
 8048775:	mov    ebx,0x8049f20
 804877a:	sub    ebx,0x8049f1c
 8048780:	sar    ebx,0x2
 8048783:	sub    ebx,0x1
 8048786:	cmp    eax,ebx
 8048788:	jae    80487a8 <__do_global_dtors_aux+0x48>
 804878a:	lea    esi,[esi+0x0]
 8048790:	add    eax,0x1
 8048793:	mov    ds:0x804a06c,eax
 8048798:	call   DWORD PTR [eax*4+0x8049f1c]
 804879f:	mov    eax,ds:0x804a06c
 80487a4:	cmp    eax,ebx
 80487a6:	jb     8048790 <__do_global_dtors_aux+0x30>
 80487a8:	mov    BYTE PTR ds:0x804a068,0x1
 80487af:	add    esp,0x4
 80487b2:	pop    ebx
 80487b3:	pop    ebp
 80487b4:	ret    
 80487b5:	lea    esi,[esi+eiz*1+0x0]
 80487b9:	lea    edi,[edi+eiz*1+0x0]

080487c0 <frame_dummy>:
 80487c0:	push   ebp
 80487c1:	mov    ebp,esp
 80487c3:	sub    esp,0x18
 80487c6:	mov    eax,ds:0x8049f24
 80487cb:	test   eax,eax
 80487cd:	je     80487e1 <frame_dummy+0x21>
 80487cf:	mov    eax,0x0
 80487d4:	test   eax,eax
 80487d6:	je     80487e1 <frame_dummy+0x21>
 80487d8:	mov    DWORD PTR [esp],0x8049f24
 80487df:	call   eax
 80487e1:	leave  
 80487e2:	ret    
 80487e3:	nop

void wait_for_child(void){
	while(waitpid(-1,0x0,0x1) > 0){
		//loop
	}
	return;
}

buf[0x800]<-esp-0x820,ebp-0x80c

0<-ebp-0xc
ebx<-ebp-8
edi<-ebp-4
ebp<-ebp
ret<-ebp+4
arg1<-ebp+8

void handle(int acceptfd){
	stack := 0x820
	char buf[0x800] = {0};//@[ebp-0x80c]
	DWORD my_canary = 0;//@[ebp-0xc]

	srand(time(NULL));
	ds_0x804a074 = rand();
	my_canary = ds_0x804a074;
	*((DWORD *)buf) = (DWORD)&buf;
	send(acceptfd,buf,0x4,0x0);
	send(acceptfd,my_canary,0x4,0x0);
	send(acceptfd,"Welcome to CSAW CTF.  Exploitation 2 will be a little harder this year.  Insert your exploit here:",0x63,0x0);
	recv(acceptfd,buf,0x1000,0x0);
	buf[800] = 0x0;

	if(my_canary != ds_0x804a074){
		close(acceptfd);
		exit(0x0);
	}

	return;
}

int main(void){
	stack := 0x100
	socklen_t addrlen := [esp+0x2c]
	struct sockaddr_in *addr := [esp+0x30]
	DWORD optval := [esp+0x40]
	struct addrinfo *res := [esp+0x44]
	struct addrinfo hints := [esp+0x48]
	struct sigaction act := [esp+0x68]
	int pid := [esp+0xf4]
	int acceptfd := [esp+0xf8]
	int fd := [esp+0xfc]

	[esp+0x40] = 1;
	hints = {0};
	hints.ai_family = AF_INET;//0x2
	hints.ai_socktype = SOCK_STREAM;//0x1
	

	if(getaddrinfo("0.0.0.0","31338",&hints,&res) != 0){
		perror("getaddrinfo");
		return 1;
	}

	fd = socket(hints.ai_family,hints.ai_socktype,hints.ai_protocol);
	if(fd == -1){
		perror("socket");
		return 1;
	}

	if(setsocketopt(fd,SOL_SOCKET,SO_REUSEADDR,&optval,optlen) == -1){
		perror("setsockopt");
		return 1;
	}

	if(bind(fd,hints.ai_addr,hints.ai_addrlen) == -1){
		perror("bind");
		return 1;
	}

	if(listen(fd,0x64) == -1){
		perror("listen");
		return 1;
	}

	freeaddrinfo(hints);
	act.sa_handler = wait_for_child
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	if(sigaction(SIGCHLD,&act,NULL) == -1){
		perror("sigaction");
		return 1;
	}

	while(1){
		addrlen = 0x10;
		acceptfd = accept(fd,&addr,&addrlen);
		if(acceptfd == -1){
			perror("accept");
			return 0;
		}

		htons(addr.sin_port);
		inet_ntoa(addr.sin_addr);
		printf("Got a connection from %s on port %d\n",htons(addr.sin_port),inet_ntoa(addr.sin_addr));
	

		pid = fork()
		if(pid == 0){
			close(fd);
			handle(acceptfd);
			return 0;
		}else{
			if(pid == -1){
				perror("fork");
				return 1;
			}else{
				close(acceptfd);
			}
		}
	}
}

08048c20 <__libc_csu_init>:
 8048c20:	push   ebp
 8048c21:	push   edi
 8048c22:	push   esi
 8048c23:	push   ebx
 8048c24:	call   8048c92 <__i686.get_pc_thunk.bx>
 8048c29:	add    ebx,0x13cb
 8048c2f:	sub    esp,0x1c
 8048c32:	mov    ebp,DWORD PTR [esp+0x30]
 8048c36:	lea    edi,[ebx-0xe0]
 8048c3c:	call   804856c <_init>
 8048c41:	lea    eax,[ebx-0xe0]
 8048c47:	sub    edi,eax
 8048c49:	sar    edi,0x2
 8048c4c:	test   edi,edi
 8048c4e:	je     8048c79 <__libc_csu_init+0x59>
 8048c50:	xor    esi,esi
 8048c52:	lea    esi,[esi+0x0]
 8048c58:	mov    eax,DWORD PTR [esp+0x38]
 8048c5c:	mov    DWORD PTR [esp],ebp
 8048c5f:	mov    DWORD PTR [esp+0x8],eax
 8048c63:	mov    eax,DWORD PTR [esp+0x34]
 8048c67:	mov    DWORD PTR [esp+0x4],eax
 8048c6b:	call   DWORD PTR [ebx+esi*4-0xe0]
 8048c72:	add    esi,0x1
 8048c75:	cmp    esi,edi
 8048c77:	jne    8048c58 <__libc_csu_init+0x38>
 8048c79:	add    esp,0x1c
 8048c7c:	pop    ebx
 8048c7d:	pop    esi
 8048c7e:	pop    edi
 8048c7f:	pop    ebp
 8048c80:	ret    
 8048c81:	jmp    8048c90 <__libc_csu_fini>
 8048c83:	nop
 8048c84:	nop
 8048c85:	nop
 8048c86:	nop
 8048c87:	nop
 8048c88:	nop
 8048c89:	nop
 8048c8a:	nop
 8048c8b:	nop
 8048c8c:	nop
 8048c8d:	nop
 8048c8e:	nop
 8048c8f:	nop

08048c90 <__libc_csu_fini>:
 8048c90:	repz ret 

08048c92 <__i686.get_pc_thunk.bx>:
 8048c92:	mov    ebx,DWORD PTR [esp]
 8048c95:	ret    
 8048c96:	nop
 8048c97:	nop
 8048c98:	nop
 8048c99:	nop
 8048c9a:	nop
 8048c9b:	nop
 8048c9c:	nop
 8048c9d:	nop
 8048c9e:	nop
 8048c9f:	nop

08048ca0 <__do_global_ctors_aux>:
 8048ca0:	push   ebp
 8048ca1:	mov    ebp,esp
 8048ca3:	push   ebx
 8048ca4:	sub    esp,0x4
 8048ca7:	mov    eax,ds:0x8049f14
 8048cac:	cmp    eax,0xffffffff
 8048caf:	je     8048cc4 <__do_global_ctors_aux+0x24>
 8048cb1:	mov    ebx,0x8049f14
 8048cb6:	xchg   ax,ax
 8048cb8:	sub    ebx,0x4
 8048cbb:	call   eax
 8048cbd:	mov    eax,DWORD PTR [ebx]
 8048cbf:	cmp    eax,0xffffffff
 8048cc2:	jne    8048cb8 <__do_global_ctors_aux+0x18>
 8048cc4:	add    esp,0x4
 8048cc7:	pop    ebx
 8048cc8:	pop    ebp
 8048cc9:	ret    
 8048cca:	nop
 8048ccb:	nop

Disassembly of section .fini:

08048ccc <_fini>:
 8048ccc:	push   ebx
 8048ccd:	sub    esp,0x8
 8048cd0:	call   8048cd5 <_fini+0x9>
 8048cd5:	pop    ebx
 8048cd6:	add    ebx,0x131f
 8048cdc:	call   8048760 <__do_global_dtors_aux>
 8048ce1:	add    esp,0x8
 8048ce4:	pop    ebx
 8048ce5:	ret    
